import json, requests

from . import config as c
from . import hub

from .Error import APIError

cloudBase='https://cloud2.cozify.fi/ui/0.2/'

# auth flow based on and storing into a state config
# email -> OTP -> remoteToken -> hub ip -> hubToken
def authenticate():
    if 'email' not in  c.state['Cloud'] or not  c.state['Cloud']['email']:
         c.state['Cloud']['email'] = _getEmail()
         c.stateWrite()
    email = c.state['Cloud']['email']

    if _needRemoteToken():
        try:
            _requestlogin(email)
        except APIError:
            resetState() # a bogus email will shaft all future attempts, better to reset
            raise

        # get OTP from user, not stored anywhere since they have a very short lifetime
        otp = _getotp()
        try:
            remoteToken = _emaillogin(email, otp)
        except APIError:
            print('OTP authentication has failed.')
            resetState()
            raise

        # save the successful remoteToken
        c.state['Cloud']['remoteToken'] = remoteToken
        c.stateWrite()
    else:
        # remoteToken already fine, let's just use it
        remoteToken = c.state['Cloud']['remoteToken']

    if _needHubToken():
        hubIps = _lan_ip()
        hubkeys = _hubkeys(remoteToken)
        if not hubIps:
            raise Exception('No LAN ip returned, is your hub registered?')

        for hubIp in hubIps: # hubIps is returned as a list of all hubs
            hubInfo = hub._hub(hubIp)
            hubId = hubInfo['hubId']
            hubName = hubInfo['name']
            if hubId in hubkeys:
                hubToken = hubkeys[hubId]
            else:
                print('The hub "%s" is not linked to the given account: "%s"' % (hubName, c.state['Cloud']['email']))
                resetState()
                return False

            # if hub name not already known, create named section
            hubSection = 'Hubs.' + hubName
            if hubSection not in c.state:
                c.state[hubSection] = {}
            # if default hub not set, set this hub as the first as the default
            if 'default' not in c.state['Hubs']:
                c.state['Hubs']['default'] = hubName

            # store Hub data under it's named section
            c.state[hubSection]['hubToken'] = hubToken
            c.state[hubSection]['host'] = hubIp
            c.state[hubSection]['hubId'] = hubId # not really used for anything but doesn't hurt
            c.stateWrite()
    return True

# reset cloudstate to allow full retry of authentication
# does not reset hub state
def resetState():
    c.state['Cloud'] = {}
    c.stateWrite()

# check if we currently hold a remoteKey.
# TODO(artanicus): need to do an OPTIONS call to check validity as well
def _needRemoteToken():
    # check if we've got a valid remoteToken
    if 'remoteToken' in c.state['Cloud']:
        if c.state['Cloud']['remoteToken'] is not None:
            return False
    return True

def _needHubToken():
    # this is a complex issue, for now just return a naive if default hub key is there, assume it's good
    if 'default' not in c.state['Hubs'] or 'hubtoken' not in c.state['Hubs.' + c.state['Hubs']['default']]:
        return True
    else:
        return False

def _getotp():
    return input('OTP from your email: ')

def _getEmail():
    return input('Enter your Cozify account email address: ')

# 1:1 implementation of user/requestlogin
# email: cozify account email
# returns success Bool
def _requestlogin(email):
    payload = { 'email': email }
    response = requests.post(cloudBase + 'user/requestlogin', params=payload)
    if response.status_code is not 200:
        raise APIError(response.status_code, response.text)

# 1:1 implementation of user/emaillogin
# email: cozify account email
# otp: OTP provided by user, generated by requestlogin
# returns remote-key
def _emaillogin(email, otp):
    payload = {
            'email': email,
            'password': otp
    }

    response = requests.post(cloudBase + 'user/emaillogin', params=payload)
    if response.status_code == 200:
        return response.text
    else:
        raise APIError(response.status_code, response.text)

# 1:1 implementation of hub/lan_ip
# returns list of hub ip's
# Oddly enough remoteToken isn't needed here and on the flipside doesn't help.
# By testing it seems hub/lan_ip will use the source ip of the request to determine the validity of the request.
# Thus, only if you're making the request from the same public ip (or ip block?) will this call succeed with useful results
def _lan_ip():
    response = requests.get(cloudBase + 'hub/lan_ip')
    if response.status_code == 200:
        return json.loads(response.text)
    else:
        raise APIError(response.status_code, response.text)

# 1:1 implementation of user/hubkeys
# remoteToken: cozify Cloud remoteToken
# returns map of hubs: { hubId: hubToken }
def _hubkeys(remoteToken):
    headers = {
            'Authorization': remoteToken
    }
    response = requests.get(cloudBase + 'user/hubkeys', headers=headers)
    if response.status_code == 200:
        return json.loads(response.text)
    else:
        raise APIError(response.status_code, response.text)
